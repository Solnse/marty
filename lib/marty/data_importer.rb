module Marty
  class DataImporterError < StandardError
    attr_reader :lines

    def initialize(message, lines)
      super(message)
      @lines = lines
    end
  end

  class DataImporter
    MCFLY_COLUMNS = Set[
                        "id",
                        "group_id",
                        "user_id",
                        "created_dt",
                        "obsoleted_dt",
                        "o_user_id",
                       ]

    class RowProcessor
      attr_accessor :klass, :headers, :dt, :synonyms, :key_attrs, :hmap

      EXCEL_START_DATE = Date.parse('1/1/1900')-2

      # Given a Mcfly class, return the set of attributes (excluding id)
      # used to uniquely identify an instance.
      def self.get_keys(klass)
        raise "bad class arg #{klass}" unless
          klass.is_a?(Class) && klass < ActiveRecord::Base

        attrs = klass.const_get(:MCFLY_UNIQUENESS)

        raise "class has no :MCFLY_UNIQUENESS" unless attrs

        attrs = attrs[0..-2] + attrs.last.fetch(:scope, []) if
          attrs.last.is_a?(Hash)
        attrs -= [:obsoleted_dt]

        raise "key list for #{klass} is empty" if attrs.empty?
        attrs
      end

      def self.assoc_info(klass, a)
        assoc_class = klass.reflect_on_association(a.to_sym).klass
        keys = self.get_keys(assoc_class) rescue nil

        if keys
          raise "#{klass}-#{assoc_class} key list too long: #{keys}" unless
            keys.length == 1
          assoc_key = keys.first
        else
          assoc_key = assoc_class.attribute_names.reject{|x| x=="id"}.first
        end

        {assoc_key: assoc_key, assoc_class: assoc_class, mcfly: keys}
      end

      FLOAT_PAT = /^-?\d+(\.\d+)?$/

      PATS = {
        integer: 	/^-?\d+(\.0+)?$/,
        float: 		FLOAT_PAT,
        decimal: 	FLOAT_PAT,
      }

      def convert(v, type)
        pat = PATS[type]

        raise "bad #{type} #{v.inspect}" unless (!pat || v =~ pat)

        case type
        when :boolean
          case v.downcase
          when "true" then true
          when "false" then false
          else raise "unknown boolean #{v}"
          end
        when :string
          v
        when :integer
          v.to_i
        when :float
          v.to_f
        when :decimal
          BigDecimal(v)
        when :date
          # Dates are kept as float in Google spreadsheets.  Need to
          # convert them to dates.
          v =~ FLOAT_PAT ? EXCEL_START_DATE + v.to_f : v.to_date
        when :datetime
          v.to_datetime
        else
          raise "unknown type #{type} for #{v}"
        end
      end

      def initialize(klass, headers, dt, synonyms)
        @klass 		= klass
        @headers 	= headers
        @dt		= dt
        @synonyms 	= synonyms
        @key_attrs 	= self.class.get_keys(klass)

        # # HACK: not sure why there's a nil at the end of headers sometimes
        # headers.pop if headers[-1].nil?

        raise "row headers have nil! #{headers.inspect}" unless headers.all?

        associations = klass.reflect_on_all_associations.map(&:name)

        cols = klass.columns.inject({}) { |h, c|
          h[c.name] = c
          h
        }

        @hmap = headers.inject({}) { |h, a|
          # handle klass__attr type headers generated by Netzke.  Just
          # keeps klass since we should be able to find the key attr.
          a = $1 if a =~ /(.*)__/

          if associations.member?(a.to_sym)
            h[a] = self.class.assoc_info(klass, a)
          else
            raise "unknown column #{a}" unless cols[a]
            h[a] = cols[a].type
          end
          h
        }
      end

      def create_or_update(row)
        options = row.each_with_object({}) { |(a, v), h|
          # ignore Mcfly columns
          next if Marty::DataImporter::MCFLY_COLUMNS.member? a

          a = $1 if a =~ /(.*)__/
          v = (synonyms[a] || {}).fetch(v, v)

          if hmap[a].is_a? Hash
            if !v
              h["#{a}_id"] = nil
              next
            end

            srch = {hmap[a][:assoc_key] => v}
            srch[:obsoleted_dt] = 'infinity' if hmap[a][:mcfly]
            av = hmap[a][:assoc_class].where(srch).first

            raise "#{v.inspect} not found #{hmap[a][:assoc_class]}" unless av

            h["#{a}_id"] = av.id
          else
            raise "bad col #{a} value #{v}, row: #{row}" unless hmap[a]

            # if it's not a hash (association) then its a type symbol
            h[a] = v && convert(v, hmap[a])
          end
        }

        find_options = options.select { |k,v| key_attrs.member? k.to_sym }

        raise "invalid entry" if find_options.empty?

        find_options['obsoleted_dt'] = 'infinity'

        obj = klass.where(find_options).first || klass.new

        options.each { |k, v| obj.send "#{k}=", v }

        tag = obj.new_record? ? :create : (obj.changed? ? :update : :same)

        raise "old created_dt >= current version #{obj} #{obj.created_dt} #{dt}" if
          (tag == :update) && (dt != 'infinity') && (obj.created_dt > dt)

        obj.created_dt = dt unless tag == :same || dt == 'infinity'
        obj.save!

        [tag, obj.id]
      end
    end

    # perform cleaning and do_import and summarize its results
    def self.do_import_summary(klass,
                               data,
                               dt='infinity',
                               synonyms={},
                               cleaner_function=nil,
                               col_sep="\t"
                               )
      klass.transaction do
        clean_count = klass.send(cleaner_function.to_sym) if cleaner_function

        recs = self.do_import(klass, data, dt, synonyms, col_sep)

        res = Hash.new(0)
        res[:clean] = clean_count if clean_count && clean_count>0

        recs.each_with_object(res) {|(op, id), h|
          h[op] += 1
        }
      end
    end

    # Given a Mcfly klass and CSV data, import data into the database
    # and report on affected rows.  Result is an array of tuples.
    # Each tuple is associated with one data row and looks like [tag,
    # id].  Tag is one of :same, :update, :create and "id" is the id
    # of the affected row.
    def self.do_import(klass, data, dt='infinity', synonyms={}, col_sep="\t")
      csv = CSV.new(data,
                    headers: true,
                    col_sep: col_sep,
                    )

      klass.transaction do
        row_proc = nil
        res = csv.each_with_index.map { |row, line|
          begin
            row_proc ||= RowProcessor.new(klass, row.headers, dt, synonyms)

            # skip lines which are all nil
            next :blank if row.to_hash.values.none?

            row_proc.create_or_update(row)
          rescue => exc
            raise Marty::DataImporterError.new(exc.to_s, [line])
          end
        }

        ids = {}

        # raise an error if record referenced more than once.
        res.each_with_index { |(op, id), line|
          raise Marty::DataImporterError.new("record referenced more than once",
                                      [ids[id], line]) if
          op != :blank && ids.member?(id)

          ids[id] = line
        }

        res
      end
    end
  end
end
