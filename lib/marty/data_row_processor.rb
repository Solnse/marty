class Marty::DataRowProcessor
  attr_accessor :klass, :headers, :dt, :key_attrs, :hmap

  EXCEL_START_DATE = Date.parse('1/1/1900')-2

  MCFLY_COLUMNS = Set[
                      "id",
                      "group_id",
                      "user_id",
                      "created_dt",
                      "obsoleted_dt",
                      "o_user_id",
                     ]

  # Given a Mcfly class, return the set of attributes (excluding id)
  # used to uniquely identify an instance.
  def self.get_keys(klass)
    raise "bad class arg #{klass}" unless
      klass.is_a?(Class) && klass < ActiveRecord::Base

    attrs = klass.const_get(:MCFLY_UNIQUENESS)

    raise "class has no :MCFLY_UNIQUENESS" unless attrs

    attrs = attrs[0..-2] + attrs.last.fetch(:scope, []) if
      attrs.last.is_a?(Hash)
    attrs -= [:obsoleted_dt]

    raise "key list for #{klass} is empty" if attrs.empty?
    attrs
  end

  def self.assoc_info(klass, a)
    assoc_class = klass.reflect_on_association(a.to_sym).klass
    keys = self.get_keys(assoc_class) rescue nil

    assoc_keys = keys || [assoc_class.attribute_names.reject{|x| x=="id"}.first]

    {assoc_keys: assoc_keys, assoc_class: assoc_class, mcfly: keys}
  end

  FLOAT_PAT = /^-?\d+(\.\d+)?$/

  PATS = {
    integer: /^-?\d+(\.0+)?$/,
    float:   FLOAT_PAT,
    decimal: FLOAT_PAT,
  }

  def convert(v, type)
    pat = PATS[type]

    raise "bad #{type} #{v.inspect}" if
      v.is_a?(String) && pat && !(v =~ pat)

    case type
    when :boolean
      case v.to_s.downcase
      when "true", "1", "y" then true
      when "false", "0", "n" then false
      else raise "unknown boolean #{v}"
      end
    when :string, :text
      v
    when :integer
      v.to_i
    when :float
      v.to_f
    when :decimal
      v.to_d
    when :date
      # Dates are kept as float in Google spreadsheets.  Need to
      # convert them to dates. FIXME: 'infinity' as a date in
      # Rails 3.2 appears to be broken. Setting a date field to
      # 'infinity' sets it to nil.
      v =~ FLOAT_PAT ? EXCEL_START_DATE + v.to_f :
        Mcfly.is_infinity(v) ? 'infinity' : v.to_date
    when :datetime
      Mcfly.is_infinity(v) ? 'infinity' : v.to_datetime
    when :numrange, :int4range, :int8range
      v.to_s
    when :float_array, :json
      JSON.parse Marty::DataExporter.decode_json(v)
    else
      raise "unknown type #{type} for #{v}"
    end
  end

  def initialize(klass, headers, dt, _key_attrs)
    @klass     = klass
    @headers   = headers
    @dt        = dt
    @key_attrs = _key_attrs || self.class.get_keys(klass)

    # # HACK: not sure why there's a nil at the end of headers sometimes
    # headers.pop if headers[-1].nil?

    raise "row headers have nil! #{headers.inspect}" unless headers.all?

    associations = klass.reflect_on_all_associations.map(&:name)

    cols = klass.columns.each_with_object({}) { |c, h|
      h[c.name] = c
    }

    @hmap = headers.each_with_object({}) do
      |a, h|
      # handle klass__attr type headers generated by Netzke.  Just
      # keeps klass since we should be able to find the key attr.
      aclass = a.split('__').first

      if associations.member?(aclass.to_sym)
        h[a] = self.class.assoc_info(klass, aclass)
        next
      end

      raise "unknown column #{a}" unless cols[a]

      # for JSON fields in Rails 3.x type is nil, so use sql_type
      type = cols[a].type || cols[a].sql_type
      type = "#{type}_array" if cols[a].array
      h[a] = type.to_sym
    end
  end

  def create_or_update(row)
    assoc_options = {}

    options = row.each_with_object({}) do |(a, v), h|
      # ignore Mcfly columns
      next if MCFLY_COLUMNS.member? a

      if hmap[a].is_a?(Hash)
        assoc_options[a] = v
      else
        raise "bad col #{a} value #{v}, row: #{row}" unless hmap[a]

        # if it's not a hash (association) then its a type symbol
        h[a] = v && convert(v, hmap[a])
      end
    end

    assoc_groups = assoc_options.keys.group_by {|x| x.split('__').first}

    assoc_groups.each do |aclass, attrs|
      srch_class = hmap[attrs.first][:assoc_class]

      if attrs.length == 1
        a = attrs.first
        v = assoc_options[a]

        # If group has only one attr and the attr is nil or AR obj, then
        # we don't need to search.
        if v.nil? || v.is_a?(ActiveRecord::Base)
          options["#{aclass}_id"] = v && v.id
          next
        end

        # If it's an Enum, use the faster cached looked mechanism
        if Marty::Enum === srch_class
          options["#{aclass}_id"] = srch_class[ v ].id
          next
        end
      end

      srch = attrs.each_with_object({}) do |a, h|
        v = assoc_options[a]
        ac, aa = a.split('__')

        aa ||= hmap[a][:assoc_keys].first

        h[aa] = v
        h[:obsoleted_dt] = 'infinity' if hmap[a][:mcfly]
      end

      av = srch_class.where(srch).first

      raise "#{aclass} not found #{srch}" unless av

      options[ "#{aclass}_id" ] = av.id
    end

    find_options = options.select { |k,v| key_attrs.member? k.to_sym }

    raise "invalid entry: no keys" if find_options.empty?

    find_options['obsoleted_dt'] = 'infinity' if dt

    obj = klass.where(find_options).first || klass.new

    options.each do
      |k, v|
      # For each attr, check to see if it's begin changed before
      # setting it.  The AR obj.changed? doesn't work properly
      # with array, JSON or lazy attrs.
      obj.send("#{k}=", v) if obj.send(k) != v
    end

    # FIXME: obj.changed? doesn't work properly for timestamp
    # fields in Rails 3.2. It evaluates to true even when datetime
    # is not changed.  Caused by lack of awareness of timezones.
    tag = obj.new_record? ? :create : (obj.changed? ? :update : :same)

    raise "old created_dt >= current #{obj} #{obj.created_dt} #{dt}" if
      (tag == :update) && !Mcfly.is_infinity(dt) && (obj.created_dt > dt)

    obj.created_dt = dt unless tag == :same || Mcfly.is_infinity(dt) || !dt
    obj.save!

    [tag, obj.id]
  end
end
